#![allow(
    dead_code,
    clippy::needless_doctest_main,
    clippy::needless_range_loop,
    clippy::while_let_on_iterator,
    clippy::vec_init_then_push
)]

use std::collections::HashSet;

/// # Type Inference
///
/// Rust will look at how the variable is used to determine the type:
///
/// ```
/// fn takes_u32(x: u32) {
///    println!("u32: {x}");
/// }
///
/// fn takes_i8(y: i8) {
///     println!("i8: {y}");
/// }
///
/// fn main() {
///    let x = 10;
///    let y = 20;
///
///    takes_u32(x);
///    takes_i8(y);
///    // takes_u32(y); // expected `u32`, found `i8`
/// }
/// ```
///
/// It is very important to emphasize that variables declared like
/// this are not of some sort of dynamic “any type” that can hold
/// any data. The machine code generated by such declaration is identical
/// to the explicit declaration of a type. The compiler does the job for
/// us and helps us write more concise code.
///
/// The following code tells the compiler to copy into a certain generic
/// container without the code ever explicitly specifying the contained type,
/// using `_` as a placeholder:

#[allow(dead_code)]
pub fn main() {
    let mut v = Vec::new();
    v.push((10, false));
    v.push((20, true));
    println!("v: {v:?}");

    // ========================================================================
    // A turbofish in Rust code is a piece of Rust syntax that looks like ::<T>
    // ========================================================================
    //
    // let vv: HashSet<_> = v.iter().collect();
    // the type annotation for the variable can be avoided if we use tubofish
    // let vv = v.iter().collect::<HashSet<_>>();
    //

    let vv = v.iter().collect::<HashSet<_>>();
    println!("vv: {vv:?}");

    let a = [1, 2, 3];

    let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();
    assert_eq!(vec![2, 4, 6], doubled);
}
